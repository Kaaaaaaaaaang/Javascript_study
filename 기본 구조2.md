# 형 변환

함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환된다. 이런 과정을 "형 변환(type conversion)"이라고 한다.

alert가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나, 수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시이다.

이 외에, 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이라고 할 수 있다.

#### 문자형으로 변환

문자형으로의 형 변환은 문자형의 값이 필요할 때 일어난다.

alert 메서드는 매개변수로 문자형을 받기 때문에, alert(value)에서 value는 문자형이어야 한다. 만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환된다.

String(value) 함수를 호출해 전달받은 값을 문자열로 변환 할 수 있다.

```javascript
let value = true;
alert(typeof value); //boolean

value = String(value);
alert(typeof value); //string
```

false는 문자열 "false"로, null은 문자열 "null"로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어난다.

#### 숫자형으로 변환

숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.

숫자형이 아닌 값에 나누기 /를 적용한 경우와 같다.

```javascript
alert("6"/"2"); //3, 문자열이 숫자형으로 자동변환된 후 연산이 수행된다.
```

Number(value) 함수를 사용하면 주어진 값(value)을 숫자형으로 명시해서 변환할 수 있다.

```javascript
let str = "123";
alert(typeof str); //string

let num = Number(str); //문자열 "123"이 숫자 123으로 변환된다.

alert(typeof num); //number
```

숫자형 값을 사용해 무언가를 하려고 했는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우엔, 이런 명시적 형 변환이 필수이다.

한편, 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 NaN이 된다. 

#### 불린형으로 변환

이 형 변환은 논리 연산을 수행할 때 발생한다. Boolean(value)를 호출하면 명시적으로 불린으로 형 변환을 수행할 수 있다.

- 숫자 0, 빈 문자열, null, undefined, NaN과 같이 직관적으로도 "비어있다고" 느껴지는 값들은 false가 된다.
- 그 외의 값은 true로 변환된다.

```javascript
alert(Boolean(1)); //숫자 1(true)
alert(Boolean(0)); //숫자 0(false)

alert(Boolean("Hello")); //문자열(true)
alert(Boolean("")); //빈 문자열(false)
```



---



# 기본 연산자와 수학

#### 용어 : '단항', '이항', '피연산자'

피연산자(operand) : 연산자가 연산을 수행하는 대상 (=인수(argument))

​	- 5 * 2 에서 왼쪽 피연산자 5와 오른쪽 피연산자 2, 총 두 개의 피연산자가 있다.

피연산자를 하나만 받는 연산자는 단항(unary) 연산자라고 부른다. 피연산자의 부호를 뒤집는 단항 마이너스 연산자 -는 단항 연산자의 대표적인 예이다.

```javascript
let x = 1;

x = -x;
alert( x ); // -1, 단항 마이너스 연산자는 부호를 뒤집는다.
```

두 개의 피연산자를 연산자는 이항(binary) 연산자라고 부른다. 마이너스 연산자는 아래와 같이 이항 연산자로 쓸 수도 있다.

```javascript
let x = 1, y = 3;
alert( y - x ); // 2, 이항 마이너스 연산자는 뺄셈을 해준다.
```

위와 같이 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자(뺄셈 연산자)는 기호는 같지만 수행하는 연산이 다르다. 두 연산을 구분하는 기준은 피연산자의 개수이다.

#### 수학

- 덧셈 연산자 `+`,
- 뺄셈 연산자 `-`,
- 곱셈 연산자 `*`,
- 나눗셈 연산자 `/`,
- 나머지 연산자 `%`,
- 거듭제곱 연산자 `**`

#### 단항 연산자 +와 숫자형으로의 변환

덧셈 연산자 +는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있다.

숫자에 단항 덧셈 연산자를 붙이면 이 연산자는아무런 동작도 하지 않는다. 그러나 피연산자가 숫자가 아닌 경우엔 숫자형으로의 변환이 일어난다.

```javascript
// 숫자에는 아무런 영향을 미치지 않는다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화한다.
alert( +true ); // 1
alert( +"" );   // 0

let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5
```

#### 할당 연산자

무언가를 할당할 때 쓰이는 =도 연산자이다. 이 연산자는 할당(assignment) 연산자라고 불린다.

###### 값을 반환하는 할당 연산자

=는 연산자이기 때문에 함축성을 내포하고 있다. 자바스크립트에서 대부분의 연산자들은 값을 반환한다. +와 -뿐만 아니라 = 역시 값을 반환한다.

x = value을 호출하면 value가 x에 쓰여지고, 이에 더하여 value가 반환된다.

```javascript
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

###### 할당 연산자 체이닝

```javascript
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

###### 복합 할당 연산자

- +=
- -=
- *=
- /=

###### 증가 감소 연산자

- ++
- --

###### 비트 연산자

- 비트 AND ( `&` )
- 비트 OR ( `|` )
- 비트 XOR ( `^` )
- 비트 NOT ( `~` )
- 왼쪽 시프트(LEFT SHIFT) ( `<<` )
- 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
- 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

###### 쉼표 연산자

쉼표 연산자(comma operator) `,`는 코드를 짧게 쓰려는 의도로 가끔 사용된다. 

쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의해야 한다.

```javascript
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```



---



# 비교 연산자

#### 불린형 반환

- `true`가 반환되면, ‘긍정’, ‘참’, '사실’을 의미합니다.
- `false`가 반환되면, ‘부정’, ‘거짓’, '사실이 아님’을 의미합니다.

#### 문자열 비교

자바스크립트는 '사전’순으로 문자열을 비교한다. '사전편집(lexicographical)'순 이라고 불리기도 하는 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단된다.

```javascript
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

#### 다른 형을 가진 값 간의 비교

```javascript
alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행된다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행된다.
```

#### 일치 연산자

- ==

  - 동등 연산자(equality operator) ==은 0과 false를 구별하지 못한다.

    ```javascript
    alert( 0 == false ); // true
    alert('' == false); // true
    ```

- ===

  - 일치 연산자(strict equality operator) ===를 사용하면 형 변환 없이 값을 비교할 수 있다.

    ```javascript
    alert(0 === false); // false
    ```

#### null이나 undefined와 비교하기

###### 일치 연산자 `===`를 사용하여 `null`과 `undefined`를 비교

두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환된다.

```javascript
alert(null === undefined); // false
```

###### 동등 연산자 ==를 사용하여 null과 undefined를 비교

```javascript
alert(null == undefined); // true
```

###### **산술 연산자나 기타 비교 연산자** `< > <= >=`**를 사용하여** `null`**과** `undefined`**를 비교**

null과 undefined는 숫자형으로 반환된다. null은 0, undefined는 NaN으로 변한다.

#### null vs 0

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

위의 비교 결과는 논리에 맞지 않다. (3)에서 `null`은 `0`보다 크거나 같다고 했기 때문에, (1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있다.

이는 동등 연산자 `==`와 기타 비교 연산자 `> < >= <=`의 동작 방식이 다르기 때문이다. (1)에서 `null > 0`이 거짓을, (3)에서 `null >= 0`이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) `null`이 숫자형으로 변환돼 `0`이 되기 때문이다.

그런데 동등 연산자 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다. `undefined`와 `null`을 비교하는 경우에만 `true`를 반환하고, 그 이외의 경우(`null`이나 `undefined`를 다른 값과 비교할 때)는 무조건 `false`를 반환합니다. 이런 이유 때문에 (2)는 거짓을 반환한다.

#### 비교가 불가능한 undefined

undefined를 다른 값과 비교해서는 안된다.

```javascript
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

(1)`과`(2)`에선 `undefined`가 `NaN`으로 변환되는데(숫자형으로의 변환), `NaN`이 피연산자인 경우 비교 연산자는 항상 `false`를 반환한다.

undefined`는 `null`이나 `undefined`와 같고, 그 이외의 값과는 같지 않기 때문에 `(3)`은 `false`를 반환한다.